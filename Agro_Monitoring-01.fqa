{"name":"Agro Monitoring","type":"com.fibaro.genericDevice","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_806"},"sections":{"items":[{"components":[{"name":"label1","style":{"weight":"1.2"},"text":"Label","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_806"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"apiKey","value":"1"},{"name":"polygon","value":"1"},{"name":"interval","value":"600"},{"name":"httpTimeout","value":"5"},{"name":"debugLevel","value":"1"},{"name":"icon","value":"0"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"-- QuickApp AGRO MONITORING\n\n-- This QuickApp contains data of accumulated temperature and precipitation, soil temperature and moisture from OpenWeathermap via Agro Monitoring. \n\n-- Accumulated temperature and precipitation is essential to make a right decision depends on a threshold setting. Temperature quantity index calculated as the sum of daily temperatures. Humidity quantity index expressed as the sum of daily precipitation. Soil temperature and moisture are essential indices that allow your customer to adjust irrigation work and prevent crop roots damage.\n\n\n-- IMPORTANT\n-- You need an API key and Polygon ID from https://agromonitoring.com\n-- You need to create your Api key and Polygon ID at https://agromonitoring.com/dashboard/dashboard-start\n   -- After your registration click the \"New\" button in the top of the \"Create polygon\" screen.\n   -- Click on the polygon icon or square icon on the map.\n   -- Draw your polygon. If you choose a polygon shape icon do not forget to merge the first and last points to finish your polygon.\n   -- Fill in the \"Name\" field and click the \"Create\" button to save your polygon.\n-- The API is free up to 60 calls per minute and a total area of polygons\tof 1000 ha\n\n\n-- See: https://agromonitoring.com/dashboard/dashboard-start\n-- See: https://openweathermap.medium.com/dashboard-update-current-and-historical-soil-data-24422fc75c5b\n\n\n-- Current soil data is updated 2 times a day. The soil temperature is provided only in Kelvins and in this quickapp converted to Celsius (C = K - 273.15)\n\n\n-- Version 0.1 (22 May 2021)\n-- Initial version\n\n\n-- Variables (mandatory): \n-- apiKey = Get your free API key from https://agromonitoring.com\n-- polygon = Create your Polygon ID at https://agromonitoring.com/dashboard/dashboard-start\n-- interval = [number] in seconds time to get the data from the API\n-- timeout = [number] in seconds for http timeout\n-- debugLevel = Number (1=some, 2=few, 3=all, 4=simulation mode) (default = 1)\n-- icon = [numbber] User defined icon number (add the icon via an other device and lookup the number)\n\n-- Example response:\n-- {\"dt\":1522108800,\"t10\":281.96,\"moisture\":0.175,\"t0\":279.02}\n   -- dt = Time of data calculation (unix time, UTC time zone)\n   -- t10 = Temperature on the 10 centimeters depth, Kelvins\n   -- moisture = Soil moisture, m3/m3\n   -- t0 = Surface temperature, Kelvins\n\n\n-- No editing of this code is needed \n\n\nclass 'SoilMoisture'(QuickAppChild)\nfunction SoilMoisture:__init(dev)\n  QuickAppChild.__init(self,dev)\n  --self:trace(\"SoilMoisture initiated, deviceId:\",self.id)\nend\nfunction SoilMoisture:updateValue(data) \n  self:updateProperty(\"value\",tonumber(data.SoilMoisture)) \n  self:updateProperty(\"unit\", \"m³/m³\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'SoilTemp'(QuickAppChild)\nfunction SoilTemp:__init(dev)\n  QuickAppChild.__init(self,dev)\n  --self:trace(\"SoilTemp initiated, deviceId:\",self.id)\nend\nfunction SoilTemp:updateValue(data) \n  --self:debug(\"SoilTemp: \",data.SoilTemp)\n  self:updateProperty(\"value\",tonumber(data.SoilTemp))\n  self:updateProperty(\"unit\", \"°C\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'SurfaceTemp'(QuickAppChild)\nfunction SurfaceTemp:__init(dev)\n  QuickAppChild.__init(self,dev)\n  --self:trace(\"SurfaceTemp initiated, deviceId:\",self.id)\nend\nfunction SurfaceTemp:updateValue(data) \n  --self:debug(\"SurfaceTemp: \",data.SurfaceTemp)\n  self:updateProperty(\"value\",tonumber(data.SurfaceTemp))\n  self:updateProperty(\"unit\", \"°C\")\n  self:updateProperty(\"log\", \"\")\nend\n\n\n-- QuickApp functions\n\n\nlocal function getChildVariable(child,varName)\n  for _,v in ipairs(child.properties.quickAppVariables or {}) do\n    if v.name==varName then return v.value end\n  end\n  return \"\"\nend\n\n\nfunction QuickApp:logging(level,text) -- Logging function for debug\n  if tonumber(debugLevel) >= tonumber(level) then \n      self:debug(text)\n  end\nend\n\n\nfunction QuickApp:updateProperties() --Update properties\n  self:logging(3,\"updateProperties\")\n  self:updateProperty(\"log\", data.datetime)\nend\n\n\nfunction QuickApp:updateLabels() -- Update labels\n  self:logging(3,\"updateLabels\")\n  local labelText = \"\"\n  if debugLevel == 4 then\n    labelText = labelText ..\"SIMULATION MODE\" ..\"\\n\\n\"\n  end\n  \n  labelText = labelText ..\"Soil Moisture: \" ..data.SoilMoisture ..\" m³/m³\" ..\"\\n\"\n  labelText = labelText ..\"Soil Temperature (10cm): \" ..data.SoilTemp ..\" °C\" ..\"\\n\"\n  labelText = labelText ..\"Surface Temperature: \" ..data.SurfaceTemp ..\" °C\" ..\"\\n\\n\"\n  labelText = labelText ..\"Measured: \" ..data.datetime ..\"\\n\"\n  \n  self:logging(2,\"labelText: \" ..labelText)\n  self:updateView(\"label1\", \"text\", labelText) \nend\n\n\nfunction QuickApp:getValues() -- Get the values\n  self:logging(3,\"getValues\")\n  data.SoilMoisture = string.format(\"%.3f\",jsonTable.moisture)\n  data.SoilTemp = string.format(\"%.1f\",tonumber(jsonTable.t10)-273.15)\n  data.SurfaceTemp = string.format(\"%.1f\",tonumber(jsonTable.t0)-273.15)\n  data.datetime = jsonTable.dt -- Unix time, UTC time zone\n\n  -- Check timezone and daylight saving time\n  --local timezone = os.difftime(os.time(), os.time(os.date(\"!*t\",os.time())))/3600\n  --if os.date(\"*t\").isdst then -- Check daylight saving time \n  --  timezone = timezone + 1\n  --end\n  --self:logging(3,\"Timezone + dst: \" ..timezone)\n  -- Convert time of measurement to local timezone\n  --data.datetime = os.date(\"%d-%m-%Y %X\", data.datetime + (timezone*3600))\n  data.datetime = os.date(\"%d-%m-%Y %X\", data.datetime)\nend\n\n\nfunction QuickApp:simData() -- Simulate Ambee API\n  self:logging(3,\"Simulation mode\")\n  local apiResult = '{\"dt\":1522108800,\"t10\":281.96,\"moisture\":0.175,\"t0\":279.02}'\n  self:logging(3,\"apiResult: \" ..apiResult)\n\n  jsonTable = json.decode(apiResult) -- Decode the json string from api to lua-table \n  \n  self:getValues()\n  self:updateLabels()\n  self:updateProperties()\n\n  for id,child in pairs(self.childDevices) do \n    child:updateValue(data) \n  end\n  \n  self:logging(3,\"SetTimeout \" ..interval ..\" seconds\")\n  fibaro.setTimeout(interval*1000, function() \n     self:simData()\n  end)\nend\n\n\nfunction QuickApp:getData()\n  self:logging(3,\"Start getData\")\n  self:logging(2,\"URL: \" ..address)\n    \n  http:request(address, {\n    options = {data = Method, method = \"GET\", headers = {[\"Content-Type\"] = \"application/json\",[\"Accept\"] = \"application/json\",}},\n    \n      success = function(response)\n        self:logging(3,\"response status: \" ..response.status)\n        self:logging(3,\"headers: \" ..response.headers[\"Content-Type\"])\n        self:logging(2,\"Response data: \" ..response.data)\n\n        if response.data == nil or response.data == \"\" or response.data == \"[]\" or response.status > 200 then -- Check for empty result\n          self:warning(\"Temporarily no data from API\")\n          return \n          --self:logging(3,\"No data SetTimeout \" ..interval ..\" seconds\")\n          --fibaro.setTimeout(interval*1000, function() \n          --  self:getdata()\n          --end)\n        end\n\n        jsonTable = json.decode(response.data) -- JSON decode from api to lua-table\n\n        self:getValues()\n        self:updateLabels()\n        self:updateProperties()\n\n        for id,child in pairs(self.childDevices) do \n          child:updateValue(data) \n        end\n      \n      end,\n      error = function(error)\n        self:error('error: ' ..json.encode(error))\n        self:updateProperty(\"log\", \"error: \" ..json.encode(error))\n      end\n    }) \n\n  self:logging(3,\"SetTimeout \" ..interval ..\" seconds\")\n  fibaro.setTimeout((interval)*1000, function() \n     self:getData()\n  end)\nend\n\n\nfunction QuickApp:createVariables() -- Get all Quickapp Variables or create them\n  data = {}\n  data.SoilMoisture = \"0\"\n  data.SoilTemp = \"0\"\n  data.SurfaceTemp = \"0\"\n  data.datetime = \"\"\nend\n\n\nfunction QuickApp:getQuickAppVariables() -- Get all variables \n  apiKey = self:getVariable(\"apiKey\")\n  polygon = self:getVariable(\"polygon\")\n  interval = tonumber(self:getVariable(\"interval\")) \n  httpTimeout = tonumber(self:getVariable(\"httpTimeout\")) \n  debugLevel = tonumber(self:getVariable(\"debugLevel\"))\n  local icon = tonumber(self:getVariable(\"icon\")) \n\n  if apiKey ==\"\" or apiKey == nil then\n    apiKey = \"\" \n    self:setVariable(\"apiKey\",apiKey)\n    self:trace(\"Added QuickApp variable apiKey\")\n  end\n  if polygon ==\"\" or polygon == nil then\n    polygon = \"\" \n    self:setVariable(\"polygon\",polygon)\n    self:trace(\"Added QuickApp variable polygon\")\n  end\n  if interval == \"\" or interval == nil then\n    interval = \"60\" \n    self:setVariable(\"interval\",interval)\n    self:trace(\"Added QuickApp variable interval\")\n    interval = tonumber(interval)\n  end  \n  if httpTimeout == \"\" or httpTimeout == nil then\n    httpTimeout = \"5\" -- timeoout in seconds\n    self:setVariable(\"httpTimeout\",httpTimeout)\n    self:trace(\"Added QuickApp variable httpTimeout\")\n    httpTimeout = tonumber(httpTimeout)\n  end\n  if debugLevel == \"\" or debugLevel == nil then\n    debugLevel = \"1\" -- Default value for debugLevel response in seconds\n    self:setVariable(\"debugLevel\",debugLevel)\n    self:trace(\"Added QuickApp variable debugLevel\")\n    debugLevel = tonumber(debugLevel)\n  end\n  if icon == \"\" or icon == nil then \n    icon = \"0\" -- Default icon\n    self:setVariable(\"icon\",icon)\n    self:trace(\"Added QuickApp variable icon\")\n    icon = tonumber(icon)\n  end\n  if icon ~= 0 then \n    self:updateProperty(\"deviceIcon\", icon) -- set user defined icon \n  end\n\n  address = \"http://api.agromonitoring.com/agro/1.0/soil?polyid=\" ..polygon ..\"&appid=\" ..apiKey -- Combine webaddress and location info\n\n  if apiKey == nil or apiKey == \"\"  then -- Check mandatory API key \n    self:error(\"API key is empty! Get your free API key from https://agromonitoring.com\")\n    self:warning(\"No API Key: Switched to Simulation Mode\")\n    debugLevel = 4 -- Simulation mode due to empty API key\n  end\n  if polygon == nil or polygon == \"\"  then -- Check mandatory polygon ID\n    self:error(\"Polygon ID is empty! Create your Polygon ID at https://agromonitoring.com/dashboard/dashboard-start\")\n    self:warning(\"No Polygon ID: Switched to Simulation Mode\")\n    debugLevel = 4 -- Simulation mode due to empty Polygon ID\n  end\n\nend\n\n\nfunction QuickApp:setupChildDevices()\n  local cdevs = api.get(\"/devices?parentId=\"..self.id) or {} -- Pick up all my children \n  function self:initChildDevices() end -- Null function, else Fibaro calls it after onInit()...\n\n  if #cdevs==0 then -- No children, create children\n    local initChildData = { \n      {className=\"SoilMoisture\", name=\"Soil Moisture\", type=\"com.fibaro.multilevelSensor\", value=0},\n      {className=\"SoilTemp\", name=\"Soil Temperature\", type=\"com.fibaro.temperatureSensor\", value=0},\n      {className=\"SurfaceTemp\", name=\"Surface Temp\", type=\"com.fibaro.temperatureSensor\", value=0},\n    }\n    for _,c in ipairs(initChildData) do\n      local child = self:createChildDevice(\n        {name = c.name,\n          type=c.type,\n          value=c.value,\n          unit=c.unit,\n          initialInterfaces = {}, \n        },\n        _G[c.className] -- Fetch class constructor from class name\n      )\n      child:setVariable(\"className\",c.className)  -- Save class name so we know when we load it next time\n    end   \n  else \n    for _,child in ipairs(cdevs) do\n      local className = getChildVariable(child,\"className\") -- Fetch child class name\n      local childObject = _G[className](child) -- Create child object from the constructor name\n      self.childDevices[child.id]=childObject\n      childObject.parent = self -- Setup parent link to device controller \n    end\n  end\nend\n\n\nfunction QuickApp:onInit()\n  __TAG = fibaro.getName(plugin.mainDeviceId) ..\" ID:\" ..plugin.mainDeviceId\n  self:debug(\"onInit\") \n  \n  self:setupChildDevices() -- Setup the Child Devices\n  self:getQuickAppVariables() -- Get Quickapp Variables or create them\n  self:createVariables() -- Create Variables\n\n  http = net.HTTPClient({timeout=httpTimeout*1000})\n\n  if tonumber(debugLevel) >= 4 then \n    self:simData() -- Go in simulation\n  else\n    self:getData() -- Get data from API\n  end\nend\n\n--EOF"}]}